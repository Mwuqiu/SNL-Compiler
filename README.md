# SNL Compiler Designs
 
### 实验平台为 Visual Studio 2022 
### 编程语言为 C#


### 实验方案设计
1.词法分析设计：  
词法分析采用了直接转向法对输入的源程序进行分析。根据传入字符判别所述标识符型。例如读入的是一个字母，则不断读入直到下一个字符不为字母或数字，并在保留字表中寻找检验这个标识符是否为保留字，并按照查找结果赋予token的语义信息。词法信息的错误检测主要在前后字符的搭配上，例如以标识符不可以以数字作为开头，冒号后面只能接等号构成赋值符号，单引号后的第二个字母应该为单引号等。除了检测语法错误和为token添加语义信息，在词法分析中也要顺带记录标识符的行号和列号，为后续的语法分析和语义分析的错误输出做准备。  
2.LL1语法分析设计：  
2.1检验语法错误：  
通过SYN语言的语法分析出非终极符的First集和Follow集，构建LL1分析表。通过当前符号栈与token序列的第一个token的匹配关系找到下一条产生式。再将新的产生式的内容逆序入符号栈，再次进行匹配。当发现符号栈顶与token序列的第一个终极符没有对应关系时，出现语法错误，报错。  
2.2创建语法树：  
首先创建根节点并向语法树栈中逆序压入根节点的三个儿子（child[0]，child[1]，child[2]），分别代表程序的Phead、VarK和StmlK三个子节点。伴随着程序的处理过程对语法树栈不断进行弹栈入栈，为弹出或压入栈的语法树节点添加儿子或兄弟。并根据token序列的语义信息为语法树节点添加名称、行号等信息，最终可构造出程序的语法树。  
在构造语法树过程中，还涉及操作符栈和操作数栈，它们的具体作用为提供一种后缀表达式的构造方法，用于处理程序中的计算语句。  
3.递归下降语法设计：  
3.1检验语法错误:  
根据每个非终极符的Predict集，编写对应不同非终极符的递归下降子程序。当前函数递归调用的下一层函数根据Predict的产生式和当前Token类型决定。如果当前Token类型不能匹配任何一条产生式的Predict，则生成报错信息。  
3.2创建语法树  
在适当的子程序中根据Match的Token来创建新的语法树节点并设置语法类型与语义信息，包括行号，名字等。在结束递归调用的程序之后，相应的将返回值作为当前节点的子节点/兄弟节点。最终第一次调用的子程序会返回整个语法树对应的根节点。  
3.3层次文本输出语法树  
输出语法树时，需要确定语法树节点对应的文本表示和缩进长度。其中文本表示可以由语法树节点中定义的属性及类型确定。输出函数为递归函数，父子节点和兄弟节点之间调用，并维护输出的tab长度，每次生成一行文本用以表示一个节点。  
3.4反向推出格式化代码  
是输出语法树的逆过程。首先确定每个语法树节点对应在源程序的缩进位置，输出对应格式化的缩进空格，再根据语法树结构，递归调用子节点/兄弟节点的代码生成程序，期间需要维护每次打印时的Tab数量和父节点类型，如同样的DecK节点出现在函数参数列表和Var声明时生成的代码是不同的，每次生成的文本可能位于同一行，且需要考虑换行时机和递归次序等问题。    


4.语义分析设计：  
4.1构造符号表：  
符号表中所需要填充的内容基本上是在程序的Vark部分（类型定义时）和函数定义部分填充的。程序通过语法树节点中的内容构造变量的内部表示，种类、类别以及层数和偏移。  
4.2构造类型的内部表示：  
在符号表中显示了各个层次中定义的标识符以及它们的总类和类型信息，但在语义分析中同时要记录类型array和record的内部表示。
4.3检验语义错误：   
语义错误标识符的重复定义、无声名的标识符和数组上下标越界等错误。处理这样的错误的依据是在处理语法树的类型声明是所构造的符号表，每遇到一个标识符就在所建立的符号表中遍历一遍，找到标识符所对应的类别信息。以赋值语句为例，读到语法树的赋值节点时，进入赋值语句处理函数，读出语法树节点的两个儿子即赋值左端与赋值右端，判断这两个的类型是否一致来检查是否有赋值类型不相容的问题。  
